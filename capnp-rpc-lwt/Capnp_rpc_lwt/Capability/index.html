<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Capability (capnp-rpc-lwt.Capnp_rpc_lwt.Capability)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">capnp-rpc-lwt</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Capnp_rpc_lwt.Capability</span></h1></header><p>A capability is a reference to an object, or to a promise for an object.
You can invoke methods on a capability even while it is still only a
promise.</p><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code></code><code></code></div><div class="doc"><p>An <code class="code">'a t</code> is a capability reference to a service of type <code class="code">'a</code>.</p></div></div><div class="spec val" id="val-problem"><a href="#val-problem" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>problem : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> option</code></div><div class="doc"><p><code class="code">problem t</code> is <code class="code">Some ex</code> if <code class="code">t</code> is broken, or <code class="code">None</code> if it is still
believed to be healthy. Once a capability is broken, it will never
work again and any calls made on it will fail with exception <code class="code">ex</code>.</p></div></div><div class="spec module" id="module-Request"><a href="#module-Request" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Request/index.html">Request</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec val" id="val-call"><a href="#val-call" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span>) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="../StructRef/index.html#type-t">StructRef.t</a></code></div><div class="doc"><p><code class="code">call target m req</code> invokes <code class="code">target#m req</code> and returns a promise for the result.
Messages may be sent to the capabilities that will be in the result
before the result arrives - they will be pipelined to the service
responsible for resolving the promise. The caller must call <code class="code">StructRef.dec_ref</code>
when finished with the result (consider using one of the <code class="code">call_*</code> functions below
instead for a simpler interface).</p></div></div><div class="spec val" id="val-call_and_wait"><a href="#val-call_and_wait" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_and_wait : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t<span class="keyword"> * </span>(unit <span class="keyword">&#8209;&gt;</span> unit)) <a href="../index.html#type-or_error">or_error</a> Lwt.t</code></div><div class="doc"><p><code class="code">call_and_wait t m req</code> does <code class="code">call t m req</code> and waits for the response.
This is simpler than using <code class="code">call</code>, but doesn't support pipelining
(you can't use any capabilities in the response in another message until the
response arrives).
On success, it returns <code class="code">Ok (response, release_response_caps)</code>.
Call <code class="code">release_response_caps</code> when done with the results, to release any capabilities it might
contain that you didn't use (remembering that future versions of the protocol might add
new optional capabilities you don't know about yet).
If you don't need any capabilities from the result, consider using <code class="code">call_for_value</code> instead.
Doing <code class="code">Lwt.cancel</code> on the result will send a cancel message to the target
for remote calls.</p></div></div><div class="spec val" id="val-call_for_value"><a href="#val-call_for_value" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_for_value : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t <a href="../index.html#type-or_error">or_error</a> Lwt.t</code></div><div class="doc"><p><code class="code">call_for_value t m req</code> is similar to <code class="code">call_and_wait</code>, but automatically
releases any capabilities in the response before returning. Use this if
you aren't expecting any capabilities in the response.</p></div></div><div class="spec val" id="val-call_for_value_exn"><a href="#val-call_for_value_exn" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_for_value_exn : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t Lwt.t</code></div><div class="doc"><p>Wrapper for <code class="code">call_for_value</code> that turns errors into Lwt failures.</p></div></div><div class="spec val" id="val-call_for_unit"><a href="#val-call_for_unit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_for_unit : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> unit <a href="../index.html#type-or_error">or_error</a> Lwt.t</code></div><div class="doc"><p>Wrapper for <code class="code">call_for_value</code> that ignores the result.</p></div></div><div class="spec val" id="val-call_for_unit_exn"><a href="#val-call_for_unit_exn" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_for_unit_exn : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> unit Lwt.t</code></div><div class="doc"><p>Wrapper for <code class="code">call_for_unit</code> that turns errors into Lwt failures.</p></div></div><div class="spec val" id="val-call_for_caps"><a href="#val-call_for_caps" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>call_for_caps : <span class="type-var">'t</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t) Capnp.RPC.MethodID.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span> <a href="../StructRef/index.html#type-t">StructRef.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span></code></div><div class="doc"><p><code class="code">call_for_caps target m req extract</code> is a wrapper for <code class="code">call</code> that passes the results promise to
<code class="code">extract</code>, which should extract any required capability promises from it.
In the common case where you want a single cap &quot;foo&quot; from the result, use
<code class="code">call_for_caps target m req Results.foo_get_pipelined</code>.
When the remote call finally returns, the result will be released automatically.</p></div></div><div class="spec type" id="type-resolver"><a href="#type-resolver" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a resolver</code><code></code><code></code></div><div class="doc"><p>An <code class="code">'a resolver</code> can be used to resolve a promise for an <code class="code">'a</code>. It can only be used once.</p></div></div><div class="spec val" id="val-promise"><a href="#val-promise" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>promise : unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'t</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a></code></div><div class="doc"><p><code class="code">promise ()</code> returns a fresh local promise and a resolver for it.
Any calls made on the promise will be queued until it is resolved.</p></div></div><div class="spec val" id="val-resolve_ok"><a href="#val-resolve_ok" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>resolve_ok : <span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">resolve_ok r x</code> resolves <code class="code">r</code>'s promise to <code class="code">x</code>. <code class="code">r</code> takes ownership of <code class="code">x</code>
(the caller must use <code class="code">inc_ref</code> first if they want to continue using it).</p></div></div><div class="spec val" id="val-resolve_exn"><a href="#val-resolve_exn" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>resolve_exn : <span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a> <span class="keyword">&#8209;&gt;</span> <a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">resolve_exn r x</code> breaks <code class="code">r</code>'s promise with exception <code class="code">x</code>.</p></div></div><div class="spec val" id="val-inc_ref"><a href="#val-inc_ref" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>inc_ref : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">inc_ref t</code> increases the ref-count on <code class="code">t</code> by one.</p></div></div><div class="spec val" id="val-dec_ref"><a href="#val-dec_ref" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dec_ref : <span class="type-var">_</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">dec_ref t</code> decreases the ref-count on <code class="code">t</code> by one. When the count reaches zero,
the capability is released. This may involve sending a notification to a remote
peer. Any time you extract a capability from a struct or struct promise,
it must eventually be freed by calling <code class="code">dec_ref</code> on it.</p></div></div><div class="spec val" id="val-pp"><a href="#val-pp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> Fmt.t</code></div><div class="doc"></div></div></body></html>